diff --git a/sudoku/client/clientgui.py b/sudoku/client/clientgui.py
index 47cc87a..37cecb2 100644
--- a/sudoku/client/clientgui.py
+++ b/sudoku/client/clientgui.py
@@ -114,7 +114,7 @@ def client_gui_main(args=None):
     if m.session:
         gameplayGUI = Gameplay(addressGUI.address, m.session, client)
     else:
-        print("session is empty -- probably from multiplayerdiaglo")
+        print("session is empty -- probably from multiplayerdialog")
 
 
 if __name__ == '__main__':
diff --git a/sudoku/client/clientterminal.py b/sudoku/client/clientterminal.py
index 7777a66..cb54b3b 100644
--- a/sudoku/client/clientterminal.py
+++ b/sudoku/client/clientterminal.py
@@ -8,33 +8,20 @@ from time import sleep
 from sudoku.client.game_server_discovery import GameServerDiscovery
 from sudoku.client.rpc_client import RpcClient
 from sudoku.common import protocol
+from sudoku.client.ic_update_link import ICUpdate_link
 
 
 class ClientTerminal:
     def __init__(self):
         self.current_session = None
         self.client_specifier = "default"  # used by server to distinguish clients for matching up link backs
+        self.update_link = None
         self.rpcClient = None
 
     def leave_session(self):
         # self.gameUpdateLink.destroy()
         pass
 
-    def send_request(self, m):
-        """
-        Send requests to the server and waits for the response.
-        :param m: The message that is sent to the server.
-        :return: Processed response from the server.
-        """
-        self.socket.sendall(m)
-        rsp = self.socket.recv(10000)
-        if rsp == protocol._ACK:
-            return True
-        elif rsp == protocol._RSP_SESSION_FULL:
-            return False
-        else:
-            return pickle.loads(rsp)
-
     def update(self, user_action, current_session):
         """
         This method allows the user to make a change to the sudoku game.
@@ -47,12 +34,11 @@ class ClientTerminal:
         column = user_action[2]
         number = user_action[3]
 
-        update_request = self.send_request(protocol._REQ_UPDATE_GAME + protocol._MSG_FIELD_SEP +
+        update_request = self.rpcClient.call(protocol._REQ_UPDATE_GAME + protocol._MSG_FIELD_SEP +
                                            row + protocol._MSG_FIELD_SEP + column + protocol._MSG_FIELD_SEP + number)
 
-        # print update_request
-        #if update_request.game_state != current_session.game_state:
-        if update_request[1]:
+        update_request = pickle.loads(update_request)
+        if update_request[1] == True:
             print 'correct'
         else:
             print 'incorrect'
@@ -101,10 +87,10 @@ class ClientTerminal:
         # self.send_request(protocol._REQ_NICKNAME + protocol._MSG_FIELD_SEP + n)
         res = self.rpcClient.call(protocol._REQ_NICKNAME + protocol._MSG_FIELD_SEP + n)
         print(res)
-        if res == protocol._ACK:
+        if res == protocol._RSP_OK:
             print("nickname accepted")
         else:
-            print("nickname did not accepted!")
+            print("nickname did not accepted!") # TODO: print why not!
         return
 
     def connect(self, serv_addr='localhost'):
@@ -120,10 +106,10 @@ class ClientTerminal:
             exit(-1)
 
         res = self.rpcClient.call(protocol._REQ_INITIAL_CONNECT)
-        if res == protocol._ACK:
+        if res == protocol._RSP_OK:
             print("connected successfuly!")
         else:
-            print("some problem with connection!")
+            print("some problem with connection!") # TODO: print why not!
         return
 
     def join_session(self, user_action):
@@ -134,11 +120,15 @@ class ClientTerminal:
         number of players
         """
         session_id = user_action.split(' ')[1]
-        rsp = self.send_request(protocol._REQ_JOIN_SESSION + protocol._MSG_FIELD_SEP + session_id)
+        rsp = self.rpcClient.call(protocol._REQ_JOIN_SESSION + protocol._MSG_FIELD_SEP + session_id)
+        # TODO: use simpler output for the joining session (on server!)
         if type(rsp) != bool:
             return rsp
         else:
-            return 'session full'
+            if rsp == protocol._RSP_SESSION_FULL:
+                return 'session full'
+            else:
+                return "UUID is not available"
 
     def find_self(self):
         """
@@ -182,7 +172,8 @@ class ClientTerminal:
             inf = user_action.split(' ')
         elif user_action.startswith('-join'):
             rsp = self.join_session(user_action)
-            self.gameUpdateLink.create(self.socket.getsockname())
+            # self.gameUpdateLink.create(self.socket.getsockname())
+            # TODO: self.update_link = ICUpdate_link(rsp.game_name or sth similar)
             # print "--- we're joined --- "
             # print rsp
             if type(rsp) == str:
@@ -197,8 +188,8 @@ class ClientTerminal:
                 print 'my score is: ', score
             else: 
                 print "currenty not in a session"
-        elif user_action.startswith('-sn'):
-            print self.socket.getsockname()
+        # elif user_action.startswith('-sn'):
+        #     print self.socket.getsockname()
         elif user_action.startswith(protocol._TERMINATOR):
             self.send_request(protocol._TERMINATOR)
 
diff --git a/sudoku/common/protocol.py b/sudoku/common/protocol.py
index 0dcbb23..494776f 100644
--- a/sudoku/common/protocol.py
+++ b/sudoku/common/protocol.py
@@ -21,12 +21,16 @@ _REQ_NICKNAME = 'c5'
 _REQ_UPDATE_GAME = 'c7'
 
 # server responses
+_RSP_OK = 'sr0'
+_RSP_SOME_ERROR = 'sr0.1'
 _RSP_CURRENT_SESSIONS = 'sr1'
 _RSP_SESSION_JOINED = 'sr2.1'
 _RSP_SESSION_FULL = 'sr2.2'
 _RSP_LEAVE_SESSION = 'sr3'
 _RSP_GAME_UPDATE_CORRECT = 'sr4.1'
 _RSP_GAME_UPDATE_INCORRECT = 'sr4.2'
+_RSP_NO_GAME_FOUND = 'sr5'
+_RSP_USER_NOT_EXISTING = 'sr6'
 
 # server actions
 _SA_CREATE_SESSION = 'sa1'
diff --git a/sudoku/server/server.py b/sudoku/server/server.py
index 24ba203..75fb989 100644
--- a/sudoku/server/server.py
+++ b/sudoku/server/server.py
@@ -150,70 +150,83 @@ def request_handler(msg, uuid, args):
         if protocol.server_process(msg) == protocol._SA_NEW_PLAYER:
             print("NEW PLAYER RQST")
             current_players[uuid] = Player(uuid)
-            return protocol._ACK
+            return protocol._RSP_OK
 
         elif protocol.server_process(msg) == protocol._SA_NICKNAME:
             print("NICKNAME RQST")
-            if uuid in current_players.keys():
-                player = current_players[uuid]
-                player.nickname = msg.split(protocol._MSG_FIELD_SEP)[1]
-                return protocol._ACK
-            else:
-                return False
+            if uuid not in current_players.keys():
+                return protocol._RSP_USER_NOT_EXISTING
+
+            player = current_players[uuid]
+            player.nickname = msg.split(protocol._MSG_FIELD_SEP)[1]
+            return protocol._RSP_OK
 
         elif protocol.server_process(msg) == protocol._SA_CREATE_SESSION:
             print("CREATE SESSION RQST")
-            if uuid in current_players.keys():
-                player = current_players[uuid]
-                created_session = games.new_session(msg, player)
-                pickle_session = pickle.dumps(created_session)
-                return pickle_session
-            else:
-                return False
+            if uuid not in current_players.keys():
+                return protocol._RSP_USER_NOT_EXISTING
+
+            player = current_players[uuid]
+            created_session = games.new_session(msg, player)
+            pickle_session = pickle.dumps(created_session)
+            return pickle_session # TODO: return acknowledgement here
+            # TODO: send session through other channel!
+
 
         elif protocol.server_process(msg) == protocol._SA_JOIN_SESSION:
             print("JOIN SESSION RQST")
-        #
-        #     joined_session = games.join_session(msg, player)
-        #     if joined_session:
-        #         pickle_session = pickle.dumps(joined_session)
-        #         sock.send(pickle_session)
-        #     else:
-        #         sock.send(protocol._RSP_SESSION_FULL)
-        #
-        #     for other_player in joined_session.current_players:
-        #         # TODO: exlude the current player that upated the game!
-        #         # if other_player != player:
-        #         other_player.send_game_updates(joined_session)
-        #         print "[based a join rqst] game updates sent to : ", other_player.nickname
-        #
+            if uuid not in current_players.keys():
+                return protocol._RSP_USER_NOT_EXISTING
+
+            player = current_players[uuid]
+            joined_session = games.join_session(msg, player)
+            if joined_session:
+                pickle_session = pickle.dumps(joined_session)
+                # for other_player in joined_session.current_players:
+                #     # TODO: exlude the current player that upated the game!
+                #     # if other_player != player:
+                #     other_player.send_game_updates(joined_session)
+                #     print "[based a join rqst] game updates sent to : ", other_player.nickname
+                return pickle_session # TODO: return acknowledgement here instead
+                # TODO: send session through other channel!
+            else:
+                return protocol._RSP_SESSION_FULL
+
+
         elif protocol.server_process(msg) == protocol._SA_CURRENT_SESSIONS:
             print("GET CURRENT SESSIONS RQST")
             return pickle.dumps(games.get_sessions())
 
         elif protocol.server_process(msg) == protocol._SA_UPDATE_GAME:
             print("GAME UPDATE RQST")
-        #     print(msg)
-        #     # TODO: update Score - player.updateScore(header_part2)
-        #     # TODO: give in the game_id
-        #     s = player.current_session_id
-        #     my_session = games.get_session(s)
-        #
-        #     if my_session:
-        #         correct = my_session.update_game(msg, player)
-        #     else:
-        #         print("error: no session with id %d found!" % s)
-        #         return
-        #
-        #     print my_session.game_state
-        #
-        #     pickle_session = pickle.dumps((my_session, correct))
-        #     sock.send(pickle_session)
-        #     # send to other players of the same session
-        #     for other_player in my_session.current_players:
-        #         if other_player != player:
-        #             other_player.send_game_updates(my_session)
-        #             print "[based a game update rqst] game updates sent to ", other_player.nickname
+            # TODO: update Score - player.updateScore(header_part2)
+            # TODO: give in the game_id
+            if uuid not in current_players.keys():
+                return protocol._RSP_USER_NOT_EXISTING
+
+            player = current_players[uuid]
+            s = player.current_session_id
+            my_session = games.get_session(s)
+
+            correct = False
+            if my_session:
+                correct = my_session.update_game(msg, player)
+            else:
+                print("error: no session with id %d found!" % s)
+                return protocol._RSP_NO_GAME_FOUND
+
+            return pickle.dumps((my_session, correct)) # TODO: return acknowledgement here instead
+            # if correct:
+            #     return protocol._RSP_GAME_UPDATE_CORRECT
+            # else:
+            #     return protocol._RSP_GAME_UPDATE_INCORRECT
+
+            # TODO: send session through other channel!
+            # # send to other players of the same session
+            # for other_player in my_session.current_players:
+            #     if other_player != player:
+            #         other_player.send_game_updates(my_session)
+            #         print "[based a game update rqst] game updates sent to ", other_player.nickname
         elif msg == protocol._TERMINATOR:
             return
     except Exception as e:
